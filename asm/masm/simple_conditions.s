; LB2 from ETU Computer Organization Course

AStack SEGMENT STACK                          ; Создание сегмента стека
       DW 12 DUP(?)                           ; Отведение 12 слов памяти
AStack ENDS                                   ; Окончание сегмента стека

DATA SEGMENT                                  ; Начало сегмента данных
i1   DW ?                                     ; Результат выполнения fn1
i2   DW ?                                     ; Результат выполнения fn2
res  DW ?
a    DW 5
b    DW 4
i    DW 5462
k    DW -1
DATA ENDS                                     ; Окончание сегмента данных

; i1  = -21851
; i2  = -32768
; res =  54619

; [[Бригада 9, шифр (2, 4, 7)]]

CODE SEGMENT                                  ; Начало сегмента кода
     ASSUME CS:CODE, DS:DATA, SS:AStack       ; Привязка сегментов к регистрам

Main PROC FAR                                 ; Начало главной процедуры
     push DS                                  ; Сохранение адреса начала PSP в стеке
     sub AX, AX                               ; Обнуление регистра AX
     push AX                                  ; Загрузка нулевого кода завершения в стек
     mov AX, DATA                             ; Загрузка сегментного
     mov DS, AX                               ; регистра данных

     ; Сохраняем 3i в регистр DX
     mov DX, i                                ; Записываем в DX число i (DX = i)
     sal DX, 1                                ; Удваиваем зн-е регистра DX (DX = 2i)
     add DX, i                                ; Добавляем i к DX (DX = 3i)

     ; Сохраняем -3i в регистр BX
     mov BX, DX                               ; Сохраняем DX в BX (BX = 3i)
     neg BX                                   ; BX = -3i

     ; Проверяем условие a > b
     mov CX, a                                ; Записываем значение a в CX (CX = a)
     cmp CX, b                                ; Сравниваем значение в CX и в b
; ======================|
; 1. Заменить jg на ja  |
; ======================|
     jg  b_is_less                            ; Переходим к b_is_less, если AX (a) > b

; ===============|                                 
; Вычисление fn1 |
; ===============|
     ; [fn2 из таблицы 1]
     ;        /-(4*i+3) = -4i - 3 = -3i - i - 3, при  a>b   
     ; fn1 = <                     
     ;        \ 6*i-10 = 2 * 3i - 10           , при  a<=b
; ===============|
; Вычисление fn2 |
; ===============|
     ; [fn4 из таблицы 1]
     ;        /-(6*i-4) = -6i + 4 = 2 * (-3i) + 4, при  a>b
     ; fn2 = <                    
     ;        \ 3*(i+2) = 3i + 6                 , при  a<=b
     
; Если a <= b
     ; Далее мы изменяем DX = 3i, так как он более в программе не пригодится

     ; Вычисляем i2
     add DX, 6                                ; Добавляем 6 к DX (DX = 3i + 6)
     mov i2, DX                               ; Сохраняем DX в i2 (DX = 3i + 6)

     ; Вычисляем i1
     sal DX, 1                                ; Удваиваем DX (DX = 6i + 12)
     sub DX, 22                               ; Вычитаем 22 из DX (DX = 6i - 10)
     mov i1, DX                               ; Записываем DX в i1 (i1 = DX)
     
     jmp fn3_calc                             ; Переходим к вычислению res

; Если a > b
b_is_less:
     ; Вычисляем i1
     mov AX, BX                               ; Записываем BX в AX (AX = -3i)
     sub AX, i                                ; Отнимаем i от AX (AX = -4i)
     sub AX, 3                                ; Отнимаем от AX тройку (AX = -4i - 3)
     mov i1, AX                               ; Записываем AX в i1 (AX = -4i - 3)

     ; Сразу здесь же вычисляем i2
     sal BX, 1                                ; BX = -6i
     add BX, 4                                ; BX = -6i + 4
     mov i2, BX                               ; i2 = -6i + 4

; ===============|
; Вычисление fn3 |
; ===============|
     ; fn3 = [fn7 из таблицы 2]
     ;        / (|i1|+|i2|), при  k<0
     ; fn3 = <
     ;        \ max(6,|i1|), при  k>=0
fn3_calc:
     ; Сначала оптимально будет взять модуль от i1
     ; т.к. i1 используется в обоих случаях

     ; Сохраняем i1 и i2 в регистры, для более быстрой работы с памятью     
     mov BX, i1                               ; BX = i1
     mov DX, i2                               ; DX = i2

     ; Далее i1 = BX и i2 = DX

     ; Берём модуль от числа i1
i1_take_module:                               ; BX = |i1|  
     neg BX
; =======================================|
; 2. Заменить i1_take_module на fn3_calc |
; =======================================|
     js i1_take_module

     mov CX, k                                ; Записываем k в СX
     cmp CX, 0                                ; Сравниваем CX = k с 0     
; =======================|
; 3. Заменить jge на jae |
; =======================|
     jge k_is_non_negative                    ; Переходим к k_is_non_negative, если k < 0

     ; Берём модуль от числа i2
i2_take_module:                               ; DX = |i2|
     neg DX
; ======================|
; 4. Заменить js на jle |
; ======================|
     js i2_take_module

     ; Если k < 0
     add BX, DX                               ; Добавляем DX = |i2| к BX (BX = |i1| + |i2|)
     jmp return                               ; Завершаем выполнение программы
          
     ; Если k >= 0
k_is_non_negative:
     cmp BX, 6                                ; Сравниваем BX = |i1| и 6
; =============================|
; 5. Удалить команду jg return |
; =============================|
     jg return                                ; Проверяем условие: |i1| > 6
     mov BX, 6                                ; Записываем 6 в BX

return:                                       ; Метка завершения программы
     mov res, BX                              ; Записываем результат в переменную res
     ret                                      ; Завершаем программу
Main ENDP                                     ; Окончание главной процедуры

CODE ENDS                                     ; Окончание сегмента кода

END Main                                      ; Окончание программы и указание
                                              ; транслятору, что программу нужно
                                              ; начать с процедуры Main
